# Copyright 2023 The TensorFlow Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""Used to invoke clang-tidy on XLA.

Expects to see the output of `bazel aquery --output=jsonproto ...` via stdin,
and expects all targets of listed in aquery to have been build beforehand.

Example usage:
  bazelisk build //xla/...
  bazelisk aquery --output=jsonproto "mnemonic(CppCompile, //xla/...)"
    | python3 build_tools/clang_tidy.py

This would run clang-tidy on all files that need to be compiled to build xla.
"""
import argparse
import dataclasses
import json
import logging
import subprocess
import sys
from typing import Any, Collection

from xla.build_tools.lint import diff_parser

JSONDict = dict[Any, Any]  # Approximates parsed JSON

DISALLOWED_ARGS = {
    "-fno-canonical-system-headers",
}


@dataclasses.dataclass
class ClangTidyCommand:
  """Represents a clang-tidy command with options on a specific file."""

  file: str
  arguments: list[str]

  @classmethod
  def from_args_list(cls, args_list: list[str]) -> "ClangTidyCommand":
    """Alternative constructor which uses the args_list from `bazel aquery`.

    This collects arguments and the file being run on from the output of
    `bazel aquery`. Also filters out arguments which break clang-tidy.

    Arguments:
      args_list: List of arguments generated by `bazel aquery`

    Returns:
      The corresponding ClangTidyCommand.
    """
    cc_file = None
    filtered_args = []

    for arg in args_list:
      if arg in DISALLOWED_ARGS:
        continue

      if arg.endswith(".cc"):
        cc_file = arg

      filtered_args.append(arg)

    return cls(cc_file, filtered_args)

  def to_invocation(self) -> list[str]:
    return ["clang-tidy", self.file, "--", *self.arguments]


def extract_clang_tidy_commands(
    parsed_aquery_output: JSONDict,
    file_allowlist: Collection[str] | None,
) -> list[ClangTidyCommand]:
  """Gathers clang-tidy commands to run from `bazel aquery` JSON output.

  Arguments:
    parsed_aquery_output: Parsed JSON representing the output of `bazel aquery
      --output=jsonproto`.
    file_allowlist: The list of files to generate commands for. If None,
      generate commands for all files. Useful to only keep commands for files
      that have have been edited compared to HEAD, for example.

  Returns:
    The list of ClangTidyCommands that should be executed.
  """
  actions = parsed_aquery_output["actions"]

  commands = []
  for action in actions:
    command = ClangTidyCommand.from_args_list(action["arguments"])

    if not file_allowlist or command.file in file_allowlist:
      commands.append(command)
  return commands


def run_commands(commands: list[ClangTidyCommand]) -> list[ClangTidyCommand]:
  failed = []
  for command in commands:
    sp = subprocess.run(command.to_invocation(), check=False)
    if sp.returncode != 0:
      failed.append(command)

  return failed


def main() -> int:
  # Setup logging
  logging.basicConfig()
  logging.getLogger().setLevel(logging.INFO)

  # Parse arguments
  parser = argparse.ArgumentParser(description="Run clang-tidy on XLA.")
  parser.add_argument(
      "--changed_files_only", action=argparse.BooleanOptionalAction
  )
  args = parser.parse_args(sys.argv)

  # Gather and run clang-tidy invocations
  parsed_aquery_output = json.loads(sys.stdin.read())

  # Maybe make file_allowlist
  file_allowlist = None
  if args.changed_files_only:
    file_allowlist = {
        hunk.file
        for hunk in diff_parser.parse_hunks(diff_parser.get_git_diff_stdout())
    }

  commands = extract_clang_tidy_commands(parsed_aquery_output, file_allowlist)
  failed_invocations = run_commands(commands)
  return 1 if failed_invocations else 0


if __name__ == "__main__":
  raise SystemExit(main())
